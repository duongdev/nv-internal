name: Production Restore

# CRITICAL: This workflow restores production data from backups
# Use with extreme caution - this WILL OVERWRITE existing data
on:
  workflow_dispatch:
    inputs:
      backup_date:
        description: "Backup date to restore from (YYYY-MM-DD format)"
        required: true
        type: string
      restore_database:
        description: "Restore database"
        required: true
        type: boolean
        default: false
      restore_blobs:
        description: "Restore blob storage"
        required: true
        type: boolean
        default: false
      confirm_restore:
        description: "I understand this will OVERWRITE production data"
        required: true
        type: boolean
        default: false
      target_environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging

permissions:
  contents: read

jobs:
  # ============================================
  # Job 1: Validate Inputs
  # ============================================
  validate:
    name: Validate Restore Request
    runs-on: ubuntu-latest
    outputs:
      backup_date: ${{ inputs.backup_date }}
      restore_database: ${{ inputs.restore_database }}
      restore_blobs: ${{ inputs.restore_blobs }}

    steps:
      - name: Validate confirmation
        if: ${{ !inputs.confirm_restore }}
        run: |
          echo "::error::Restore was NOT confirmed. You must check 'I understand this will OVERWRITE production data' to proceed."
          exit 1

      - name: Validate at least one restore option
        if: ${{ !inputs.restore_database && !inputs.restore_blobs }}
        run: |
          echo "::error::No restore option selected. Select at least one of: restore_database, restore_blobs"
          exit 1

      - name: Validate backup date format
        run: |
          DATE="${{ inputs.backup_date }}"
          if ! [[ "$DATE" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            echo "::error::Invalid date format. Use YYYY-MM-DD (e.g., 2024-01-15)"
            exit 1
          fi
          echo "Backup date: $DATE"

      - name: Display restore warning
        run: |
          echo "::warning::PRODUCTION RESTORE INITIATED"
          echo ""
          echo "========================================"
          echo "  PRODUCTION RESTORE WARNING"
          echo "========================================"
          echo ""
          echo "Target Environment: ${{ inputs.target_environment }}"
          echo "Backup Date: ${{ inputs.backup_date }}"
          echo "Restore Database: ${{ inputs.restore_database }}"
          echo "Restore Blobs: ${{ inputs.restore_blobs }}"
          echo ""
          echo "This operation WILL OVERWRITE existing data!"
          echo "========================================"

      - name: Create validation summary
        run: |
          echo "## Restore Request Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Target Environment | \`${{ inputs.target_environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Backup Date | \`${{ inputs.backup_date }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Restore Database | ${{ inputs.restore_database }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Restore Blobs | ${{ inputs.restore_blobs }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Warning**: This will OVERWRITE existing data in the target environment." >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 2: Download and Decrypt Backups
  # ============================================
  download:
    name: Download & Decrypt Backups
    runs-on: ubuntu-latest
    needs: [validate]
    outputs:
      has_database: ${{ steps.check-files.outputs.has_database }}
      has_blobs: ${{ steps.check-files.outputs.has_blobs }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install Git LFS
        run: |
          sudo apt-get update
          sudo apt-get install -y git-lfs

      - name: Install GPG
        run: sudo apt-get install -y gnupg

      - name: Clone backup repository
        env:
          BACKUP_REPO_TOKEN: ${{ secrets.BACKUP_REPO_TOKEN }}
          BACKUP_REPO: ${{ secrets.BACKUP_REPO }}
        run: |
          git clone "https://x-access-token:${BACKUP_REPO_TOKEN}@github.com/${BACKUP_REPO}.git" backup-repo
          cd backup-repo
          git lfs install
          git lfs pull

      - name: Check backup exists
        id: check-backup
        run: |
          BACKUP_DATE="${{ inputs.backup_date }}"
          BACKUP_PATH="backup-repo/backups/${BACKUP_DATE}"

          if [ ! -d "$BACKUP_PATH" ]; then
            echo "::error::Backup not found for date: ${BACKUP_DATE}"
            echo "Available backups:"
            ls -la backup-repo/backups/ || echo "No backups directory found"
            exit 1
          fi

          echo "Backup found at: $BACKUP_PATH"
          ls -la "$BACKUP_PATH/"

      - name: Create working directories
        run: |
          mkdir -p encrypted
          mkdir -p decrypted
          mkdir -p restored

      - name: Copy encrypted files
        run: |
          BACKUP_DATE="${{ inputs.backup_date }}"
          cp backup-repo/backups/${BACKUP_DATE}/*.gpg encrypted/
          ls -la encrypted/

      - name: Decrypt backup files
        env:
          BACKUP_ENCRYPTION_KEY: ${{ secrets.BACKUP_ENCRYPTION_KEY }}
        run: |
          for f in encrypted/*.gpg; do
            if [ -f "$f" ]; then
              BASENAME=$(basename "$f" .gpg)
              OUTPUT_FILE="decrypted/$BASENAME"
              echo "Decrypting $f to $OUTPUT_FILE..."

              # Use GPG directly to avoid interactive prompts in decrypt script
              echo "$BACKUP_ENCRYPTION_KEY" | gpg \
                --decrypt \
                --batch \
                --yes \
                --passphrase-fd 0 \
                --output "$OUTPUT_FILE" \
                "$f"

              echo "Decrypted: $OUTPUT_FILE"
            fi
          done

          ls -la decrypted/

      - name: Check which files are available
        id: check-files
        run: |
          HAS_DATABASE="false"
          HAS_BLOBS="false"

          if ls decrypted/*.sql.gz 1> /dev/null 2>&1; then
            HAS_DATABASE="true"
            echo "Database backup found"
          fi

          if ls decrypted/blobs.tar 1> /dev/null 2>&1; then
            HAS_BLOBS="true"
            echo "Blobs backup found"
          fi

          echo "has_database=$HAS_DATABASE" >> $GITHUB_OUTPUT
          echo "has_blobs=$HAS_BLOBS" >> $GITHUB_OUTPUT

      - name: Extract blobs tarball
        if: ${{ inputs.restore_blobs }}
        run: |
          if [ -f decrypted/blobs.tar ]; then
            cd decrypted
            tar -xvf blobs.tar
            ls -la blobs/ || echo "No blobs directory after extraction"
          fi

      - name: Upload decrypted database backup
        if: ${{ inputs.restore_database }}
        uses: actions/upload-artifact@v4
        with:
          name: decrypted-database
          path: decrypted/*.sql.gz
          retention-days: 1

      - name: Upload decrypted blobs backup
        if: ${{ inputs.restore_blobs }}
        uses: actions/upload-artifact@v4
        with:
          name: decrypted-blobs
          path: decrypted/blobs/
          retention-days: 1

  # ============================================
  # Job 3: Restore Database (Conditional)
  # ============================================
  restore-database:
    name: Restore Database
    runs-on: ubuntu-latest
    needs: [validate, download]
    if: ${{ inputs.restore_database && needs.download.outputs.has_database == 'true' }}
    environment: ${{ inputs.target_environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Download decrypted database backup
        uses: actions/download-artifact@v4
        with:
          name: decrypted-database
          path: backup/

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Display restore warning
        run: |
          echo "::warning::DATABASE RESTORE - This will OVERWRITE the ${{ inputs.target_environment }} database!"
          echo ""
          echo "========================================"
          echo "  DATABASE RESTORE"
          echo "========================================"
          echo ""
          echo "Target: ${{ inputs.target_environment }}"
          echo "Backup Date: ${{ inputs.backup_date }}"
          echo ""
          echo "This will DROP and RECREATE all tables!"
          echo "========================================"

      - name: Verify database backup file
        run: |
          ls -la backup/
          BACKUP_FILE=$(ls backup/*.sql.gz | head -1)
          echo "BACKUP_FILE=$BACKUP_FILE" >> $GITHUB_ENV
          echo "Backup file: $BACKUP_FILE"

      - name: Run database restore
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          chmod +x scripts/restore-database.sh

          # In CI, we bypass the interactive confirmation with --confirm
          # The workflow already has environment protection approval
          echo "Starting database restore..."
          ./scripts/restore-database.sh "${{ env.BACKUP_FILE }}" --confirm

      - name: Verify restore
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          echo "Verifying restored database..."
          TABLE_COUNT=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" | tr -d ' ')
          echo "Tables in database: $TABLE_COUNT"

          if [ "$TABLE_COUNT" -gt 0 ]; then
            echo "Database restore verification PASSED"
          else
            echo "::warning::Database appears empty after restore"
          fi

      - name: Create restore summary
        run: |
          echo "## Database Restore Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backup Date**: ${{ inputs.backup_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: Success" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 4: Restore Blobs (Conditional)
  # ============================================
  restore-blobs:
    name: Restore Blobs
    runs-on: ubuntu-latest
    needs: [validate, download]
    if: ${{ inputs.restore_blobs && needs.download.outputs.has_blobs == 'true' }}
    environment: ${{ inputs.target_environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.15.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: "pnpm"

      - name: Get pnpm store directory
        id: pnpm-store
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_ENV

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: pnpm-store-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download decrypted blobs backup
        uses: actions/download-artifact@v4
        with:
          name: decrypted-blobs
          path: backup/blobs/

      - name: Display restore warning
        run: |
          echo "::warning::BLOB RESTORE - This will upload files to ${{ inputs.target_environment }} blob storage!"
          echo ""
          echo "========================================"
          echo "  BLOB RESTORE"
          echo "========================================"
          echo ""
          echo "Target: ${{ inputs.target_environment }}"
          echo "Backup Date: ${{ inputs.backup_date }}"
          echo ""
          ls -la backup/blobs/ || echo "No files in blobs directory"

      - name: Verify blob backup files
        run: |
          if [ ! -f backup/blobs/blobs-manifest.json ]; then
            echo "::error::Manifest file not found in blob backup"
            exit 1
          fi
          echo "Manifest found, proceeding with restore..."
          cat backup/blobs/blobs-manifest.json | head -20

      - name: Run blob restore
        env:
          BLOB_READ_WRITE_TOKEN: ${{ secrets.BLOB_READ_WRITE_TOKEN }}
        run: |
          echo "Starting blob restore..."
          pnpm tsx scripts/restore-blobs.ts --input backup/blobs --confirm

      - name: Create restore summary
        run: |
          echo "## Blob Restore Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backup Date**: ${{ inputs.backup_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: Success" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # Job 5: Final Verification
  # ============================================
  verify:
    name: Verify Restore
    runs-on: ubuntu-latest
    needs: [validate, restore-database, restore-blobs]
    if: always()

    steps:
      - name: Check restore results
        run: |
          DB_RESULT="${{ needs.restore-database.result }}"
          BLOB_RESULT="${{ needs.restore-blobs.result }}"

          echo "Database restore: $DB_RESULT"
          echo "Blob restore: $BLOB_RESULT"

          # Check if any required restore failed
          if [ "${{ inputs.restore_database }}" == "true" ] && [ "$DB_RESULT" == "failure" ]; then
            echo "::error::Database restore FAILED"
            exit 1
          fi

          if [ "${{ inputs.restore_blobs }}" == "true" ] && [ "$BLOB_RESULT" == "failure" ]; then
            echo "::error::Blob restore FAILED"
            exit 1
          fi

          echo "All requested restores completed successfully!"

      - name: Create final summary
        run: |
          echo "## Production Restore Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.restore_database }}" == "true" ]; then
            if [ "${{ needs.restore-database.result }}" == "success" ]; then
              echo "| Database | Success |" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.restore-database.result }}" == "skipped" ]; then
              echo "| Database | Skipped (no backup found) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Database | **FAILED** |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Database | Not requested |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.restore_blobs }}" == "true" ]; then
            if [ "${{ needs.restore-blobs.result }}" == "success" ]; then
              echo "| Blobs | Success |" >> $GITHUB_STEP_SUMMARY
            elif [ "${{ needs.restore-blobs.result }}" == "skipped" ]; then
              echo "| Blobs | Skipped (no backup found) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| Blobs | **FAILED** |" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "| Blobs | Not requested |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: ${{ inputs.target_environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Backup Date**: ${{ inputs.backup_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Completed**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
